// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for HealthResponseServicesDatabase.
const (
	HealthResponseServicesDatabaseDown HealthResponseServicesDatabase = "down"
	HealthResponseServicesDatabaseUp   HealthResponseServicesDatabase = "up"
)

// Defines values for HealthResponseServicesEmbeddings.
const (
	HealthResponseServicesEmbeddingsDown HealthResponseServicesEmbeddings = "down"
	HealthResponseServicesEmbeddingsUp   HealthResponseServicesEmbeddings = "up"
)

// Defines values for HealthResponseServicesScraper.
const (
	Down HealthResponseServicesScraper = "down"
	Up   HealthResponseServicesScraper = "up"
)

// Defines values for HealthResponseStatus.
const (
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for ImportResponseStatus.
const (
	Failed  ImportResponseStatus = "failed"
	Partial ImportResponseStatus = "partial"
	Success ImportResponseStatus = "success"
)

// Defines values for MessageRole.
const (
	Assistant MessageRole = "assistant"
	User      MessageRole = "user"
)

// Defines values for SearchRequestSearchType.
const (
	Hybrid   SearchRequestSearchType = "hybrid"
	Keyword  SearchRequestSearchType = "keyword"
	Semantic SearchRequestSearchType = "semantic"
)

// Defines values for ListBookmarksParamsSort.
const (
	CreatedAtAsc  ListBookmarksParamsSort = "created_at:asc"
	CreatedAtDesc ListBookmarksParamsSort = "created_at:desc"
	TitleAsc      ListBookmarksParamsSort = "title:asc"
	TitleDesc     ListBookmarksParamsSort = "title:desc"
	UpdatedAtAsc  ListBookmarksParamsSort = "updated_at:asc"
	UpdatedAtDesc ListBookmarksParamsSort = "updated_at:desc"
)

// Bookmark defines model for Bookmark.
type Bookmark struct {
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	FaviconUrl  *string            `json:"favicon_url,omitempty"`
	FolderPath  *string            `json:"folder_path,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	ScrapedAt   *time.Time         `json:"scraped_at,omitempty"`
	Tags        *[]string          `json:"tags,omitempty"`
	Title       *string            `json:"title,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Url         string             `json:"url"`
}

// BookmarkDetail defines model for BookmarkDetail.
type BookmarkDetail struct {
	// Content Scraped content of the bookmark
	Content     *string            `json:"content,omitempty"`
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	FaviconUrl  *string            `json:"favicon_url,omitempty"`
	FolderPath  *string            `json:"folder_path,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	ScrapedAt   *time.Time         `json:"scraped_at,omitempty"`
	Tags        *[]string          `json:"tags,omitempty"`
	Title       *string            `json:"title,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Url         string             `json:"url"`
}

// BookmarkListResponse defines model for BookmarkListResponse.
type BookmarkListResponse struct {
	Bookmarks  []Bookmark `json:"bookmarks"`
	Pagination Pagination `json:"pagination"`
}

// BookmarkUpdate defines model for BookmarkUpdate.
type BookmarkUpdate struct {
	Description *string   `json:"description,omitempty"`
	FolderPath  *string   `json:"folder_path,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// ChatRequest defines model for ChatRequest.
type ChatRequest struct {
	// Context Additional context bookmark IDs
	Context        *[]string           `json:"context,omitempty"`
	ConversationId *openapi_types.UUID `json:"conversation_id,omitempty"`
	Message        string              `json:"message"`
}

// ChatResponse defines model for ChatResponse.
type ChatResponse struct {
	ConversationId openapi_types.UUID `json:"conversation_id"`
	Reply          string             `json:"reply"`
	Sources        *[]Bookmark        `json:"sources,omitempty"`
}

// ConversationDetail defines model for ConversationDetail.
type ConversationDetail struct {
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Messages  []Message          `json:"messages"`
	Title     string             `json:"title"`
	UpdatedAt time.Time          `json:"updated_at"`
}

// ConversationListResponse defines model for ConversationListResponse.
type ConversationListResponse struct {
	Conversations []ConversationSummary `json:"conversations"`
}

// ConversationSummary defines model for ConversationSummary.
type ConversationSummary struct {
	CreatedAt    time.Time          `json:"created_at"`
	Id           openapi_types.UUID `json:"id"`
	MessageCount *int               `json:"message_count,omitempty"`
	Title        string             `json:"title"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

// Error defines model for Error.
type Error struct {
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   string                  `json:"error"`
	Message string                  `json:"message"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Services *struct {
		Database   *HealthResponseServicesDatabase   `json:"database,omitempty"`
		Embeddings *HealthResponseServicesEmbeddings `json:"embeddings,omitempty"`
		Scraper    *HealthResponseServicesScraper    `json:"scraper,omitempty"`
	} `json:"services,omitempty"`
	Status    HealthResponseStatus `json:"status"`
	Timestamp time.Time            `json:"timestamp"`
}

// HealthResponseServicesDatabase defines model for HealthResponse.Services.Database.
type HealthResponseServicesDatabase string

// HealthResponseServicesEmbeddings defines model for HealthResponse.Services.Embeddings.
type HealthResponseServicesEmbeddings string

// HealthResponseServicesScraper defines model for HealthResponse.Services.Scraper.
type HealthResponseServicesScraper string

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// ImportResponse defines model for ImportResponse.
type ImportResponse struct {
	Errors *[]struct {
		Error *string `json:"error,omitempty"`
		Url   *string `json:"url,omitempty"`
	} `json:"errors,omitempty"`
	Statistics struct {
		Duplicates           *int `json:"duplicates,omitempty"`
		Failed               *int `json:"failed,omitempty"`
		SuccessfullyImported *int `json:"successfully_imported,omitempty"`
		TotalFound           *int `json:"total_found,omitempty"`
	} `json:"statistics"`
	Status ImportResponseStatus `json:"status"`
}

// ImportResponseStatus defines model for ImportResponse.Status.
type ImportResponseStatus string

// Message defines model for Message.
type Message struct {
	BookmarkRefs *[]openapi_types.UUID `json:"bookmark_refs,omitempty"`
	Content      string                `json:"content"`
	CreatedAt    time.Time             `json:"created_at"`
	Id           openapi_types.UUID    `json:"id"`
	Role         MessageRole           `json:"role"`
}

// MessageRole defines model for Message.Role.
type MessageRole string

// Pagination defines model for Pagination.
type Pagination struct {
	Limit      int `json:"limit"`
	Page       int `json:"page"`
	TotalItems int `json:"total_items"`
	TotalPages int `json:"total_pages"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	Limit      *int                     `json:"limit,omitempty"`
	Query      string                   `json:"query"`
	SearchType *SearchRequestSearchType `json:"search_type,omitempty"`
}

// SearchRequestSearchType defines model for SearchRequest.SearchType.
type SearchRequestSearchType string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Results      []SearchResult `json:"results"`
	TotalResults int            `json:"total_results"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	Bookmark       Bookmark `json:"bookmark"`
	RelevanceScore float32  `json:"relevance_score"`

	// Snippet Highlighted snippet from the content
	Snippet *string `json:"snippet,omitempty"`
}

// StatsResponse defines model for StatsResponse.
type StatsResponse struct {
	BookmarkCount     int `json:"bookmark_count"`
	ConversationCount int `json:"conversation_count"`
	IndexStatus       struct {
		EmbeddingsGenerated *int       `json:"embeddings_generated,omitempty"`
		EmbeddingsPending   *int       `json:"embeddings_pending,omitempty"`
		LastIndexed         *time.Time `json:"last_indexed,omitempty"`
	} `json:"index_status"`
	StorageSizeMb *float32 `json:"storage_size_mb,omitempty"`
}

// BookmarkId defines model for BookmarkId.
type BookmarkId = openapi_types.UUID

// ConversationId defines model for ConversationId.
type ConversationId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// ListBookmarksParams defines parameters for ListBookmarks.
type ListBookmarksParams struct {
	// Page Page number (1-based)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter Filter bookmarks by title or URL
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Sort Sort field and order (e.g., "created_at:desc")
	Sort *ListBookmarksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListBookmarksParamsSort defines parameters for ListBookmarks.
type ListBookmarksParamsSort string

// ImportBookmarksMultipartBody defines parameters for ImportBookmarks.
type ImportBookmarksMultipartBody struct {
	// File Bookmark file (JSON or HTML format)
	File openapi_types.File `json:"file"`
}

// StartScrapingJSONBody defines parameters for StartScraping.
type StartScrapingJSONBody struct {
	// BookmarkIds Array of bookmark IDs to scrape
	BookmarkIds []openapi_types.UUID `json:"bookmark_ids"`
}

// ImportBookmarksMultipartRequestBody defines body for ImportBookmarks for multipart/form-data ContentType.
type ImportBookmarksMultipartRequestBody ImportBookmarksMultipartBody

// UpdateBookmarkJSONRequestBody defines body for UpdateBookmark for application/json ContentType.
type UpdateBookmarkJSONRequestBody = BookmarkUpdate

// SendChatMessageJSONRequestBody defines body for SendChatMessage for application/json ContentType.
type SendChatMessageJSONRequestBody = ChatRequest

// StartScrapingJSONRequestBody defines body for StartScraping for application/json ContentType.
type StartScrapingJSONRequestBody StartScrapingJSONBody

// SearchBookmarksJSONRequestBody defines body for SearchBookmarks for application/json ContentType.
type SearchBookmarksJSONRequestBody = SearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all bookmarks
	// (GET /api/bookmarks)
	ListBookmarks(ctx echo.Context, params ListBookmarksParams) error
	// Import bookmarks from file
	// (POST /api/bookmarks/import)
	ImportBookmarks(ctx echo.Context) error
	// Delete bookmark
	// (DELETE /api/bookmarks/{id})
	DeleteBookmark(ctx echo.Context, id BookmarkId) error
	// Get bookmark details
	// (GET /api/bookmarks/{id})
	GetBookmark(ctx echo.Context, id BookmarkId) error
	// Update bookmark
	// (PUT /api/bookmarks/{id})
	UpdateBookmark(ctx echo.Context, id BookmarkId) error
	// Re-scrape bookmark content
	// (POST /api/bookmarks/{id}/rescrape)
	RescrapeBookmark(ctx echo.Context, id BookmarkId) error
	// Send chat message
	// (POST /api/chat)
	SendChatMessage(ctx echo.Context) error
	// List conversations
	// (GET /api/chat/conversations)
	ListConversations(ctx echo.Context) error
	// Get conversation history
	// (GET /api/chat/conversations/{id})
	GetConversation(ctx echo.Context, id ConversationId) error
	// Health check
	// (GET /api/health)
	HealthCheck(ctx echo.Context) error
	// Pause scraping process
	// (POST /api/scraping/pause)
	PauseScraping(ctx echo.Context) error
	// Resume scraping process
	// (POST /api/scraping/resume)
	ResumeScraping(ctx echo.Context) error
	// Start bulk scraping process
	// (POST /api/scraping/start)
	StartScraping(ctx echo.Context) error
	// Get scraping status
	// (GET /api/scraping/status)
	GetScrapingStatus(ctx echo.Context) error
	// Stop scraping process
	// (POST /api/scraping/stop)
	StopScraping(ctx echo.Context) error
	// Hybrid search
	// (POST /api/search)
	SearchBookmarks(ctx echo.Context) error
	// System statistics
	// (GET /api/stats)
	GetSystemStats(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) ListBookmarks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBookmarksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBookmarks(ctx, params)
	return err
}

// ImportBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) ImportBookmarks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ImportBookmarks(ctx)
	return err
}

// DeleteBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBookmark(ctx, id)
	return err
}

// GetBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) GetBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBookmark(ctx, id)
	return err
}

// UpdateBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBookmark(ctx, id)
	return err
}

// RescrapeBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) RescrapeBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RescrapeBookmark(ctx, id)
	return err
}

// SendChatMessage converts echo context to params.
func (w *ServerInterfaceWrapper) SendChatMessage(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendChatMessage(ctx)
	return err
}

// ListConversations converts echo context to params.
func (w *ServerInterfaceWrapper) ListConversations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListConversations(ctx)
	return err
}

// GetConversation converts echo context to params.
func (w *ServerInterfaceWrapper) GetConversation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ConversationId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConversation(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// PauseScraping converts echo context to params.
func (w *ServerInterfaceWrapper) PauseScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PauseScraping(ctx)
	return err
}

// ResumeScraping converts echo context to params.
func (w *ServerInterfaceWrapper) ResumeScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ResumeScraping(ctx)
	return err
}

// StartScraping converts echo context to params.
func (w *ServerInterfaceWrapper) StartScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartScraping(ctx)
	return err
}

// GetScrapingStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetScrapingStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScrapingStatus(ctx)
	return err
}

// StopScraping converts echo context to params.
func (w *ServerInterfaceWrapper) StopScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StopScraping(ctx)
	return err
}

// SearchBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchBookmarks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchBookmarks(ctx)
	return err
}

// GetSystemStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStats(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStats(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/bookmarks", wrapper.ListBookmarks)
	router.POST(baseURL+"/api/bookmarks/import", wrapper.ImportBookmarks)
	router.DELETE(baseURL+"/api/bookmarks/:id", wrapper.DeleteBookmark)
	router.GET(baseURL+"/api/bookmarks/:id", wrapper.GetBookmark)
	router.PUT(baseURL+"/api/bookmarks/:id", wrapper.UpdateBookmark)
	router.POST(baseURL+"/api/bookmarks/:id/rescrape", wrapper.RescrapeBookmark)
	router.POST(baseURL+"/api/chat", wrapper.SendChatMessage)
	router.GET(baseURL+"/api/chat/conversations", wrapper.ListConversations)
	router.GET(baseURL+"/api/chat/conversations/:id", wrapper.GetConversation)
	router.GET(baseURL+"/api/health", wrapper.HealthCheck)
	router.POST(baseURL+"/api/scraping/pause", wrapper.PauseScraping)
	router.POST(baseURL+"/api/scraping/resume", wrapper.ResumeScraping)
	router.POST(baseURL+"/api/scraping/start", wrapper.StartScraping)
	router.GET(baseURL+"/api/scraping/status", wrapper.GetScrapingStatus)
	router.POST(baseURL+"/api/scraping/stop", wrapper.StopScraping)
	router.POST(baseURL+"/api/search", wrapper.SearchBookmarks)
	router.GET(baseURL+"/api/stats", wrapper.GetSystemStats)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//kHHC+BdAAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
