// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for HealthResponseServicesDatabase.
const (
	HealthResponseServicesDatabaseDown HealthResponseServicesDatabase = "down"
	HealthResponseServicesDatabaseUp   HealthResponseServicesDatabase = "up"
)

// Defines values for HealthResponseServicesEmbeddings.
const (
	HealthResponseServicesEmbeddingsDown HealthResponseServicesEmbeddings = "down"
	HealthResponseServicesEmbeddingsUp   HealthResponseServicesEmbeddings = "up"
)

// Defines values for HealthResponseServicesScraper.
const (
	Down HealthResponseServicesScraper = "down"
	Up   HealthResponseServicesScraper = "up"
)

// Defines values for HealthResponseStatus.
const (
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for ImportResponseStatus.
const (
	Failed  ImportResponseStatus = "failed"
	Partial ImportResponseStatus = "partial"
	Success ImportResponseStatus = "success"
)

// Defines values for MessageRole.
const (
	Assistant MessageRole = "assistant"
	User      MessageRole = "user"
)

// Defines values for SearchRequestSearchType.
const (
	Hybrid   SearchRequestSearchType = "hybrid"
	Keyword  SearchRequestSearchType = "keyword"
	Semantic SearchRequestSearchType = "semantic"
)

// Defines values for ListBookmarksParamsSort.
const (
	CreatedAtAsc  ListBookmarksParamsSort = "created_at:asc"
	CreatedAtDesc ListBookmarksParamsSort = "created_at:desc"
	TitleAsc      ListBookmarksParamsSort = "title:asc"
	TitleDesc     ListBookmarksParamsSort = "title:desc"
	UpdatedAtAsc  ListBookmarksParamsSort = "updated_at:asc"
	UpdatedAtDesc ListBookmarksParamsSort = "updated_at:desc"
)

// Bookmark defines model for Bookmark.
type Bookmark struct {
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	FaviconUrl  *string            `json:"favicon_url,omitempty"`
	FolderPath  *string            `json:"folder_path,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	ScrapedAt   *time.Time         `json:"scraped_at,omitempty"`
	Tags        *[]string          `json:"tags,omitempty"`
	Title       *string            `json:"title,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Url         string             `json:"url"`
}

// BookmarkDetail defines model for BookmarkDetail.
type BookmarkDetail struct {
	// Content Scraped content of the bookmark
	Content     *string            `json:"content,omitempty"`
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	FaviconUrl  *string            `json:"favicon_url,omitempty"`
	FolderPath  *string            `json:"folder_path,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	ScrapedAt   *time.Time         `json:"scraped_at,omitempty"`
	Tags        *[]string          `json:"tags,omitempty"`
	Title       *string            `json:"title,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Url         string             `json:"url"`
}

// BookmarkListResponse defines model for BookmarkListResponse.
type BookmarkListResponse struct {
	Bookmarks  []Bookmark `json:"bookmarks"`
	Pagination Pagination `json:"pagination"`
}

// BookmarkUpdate defines model for BookmarkUpdate.
type BookmarkUpdate struct {
	Description *string   `json:"description,omitempty"`
	FolderPath  *string   `json:"folder_path,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// ChatRequest defines model for ChatRequest.
type ChatRequest struct {
	// Context Additional context bookmark IDs
	Context        *[]string           `json:"context,omitempty"`
	ConversationId *openapi_types.UUID `json:"conversation_id,omitempty"`
	Message        string              `json:"message"`
}

// ChatResponse defines model for ChatResponse.
type ChatResponse struct {
	ConversationId openapi_types.UUID `json:"conversation_id"`
	Reply          string             `json:"reply"`
	Sources        *[]Bookmark        `json:"sources,omitempty"`
}

// ConversationDetail defines model for ConversationDetail.
type ConversationDetail struct {
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Messages  []Message          `json:"messages"`
	Title     string             `json:"title"`
	UpdatedAt time.Time          `json:"updated_at"`
}

// ConversationListResponse defines model for ConversationListResponse.
type ConversationListResponse struct {
	Conversations []ConversationSummary `json:"conversations"`
}

// ConversationSummary defines model for ConversationSummary.
type ConversationSummary struct {
	CreatedAt    time.Time          `json:"created_at"`
	Id           openapi_types.UUID `json:"id"`
	MessageCount *int               `json:"message_count,omitempty"`
	Title        string             `json:"title"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

// Error defines model for Error.
type Error struct {
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   string                  `json:"error"`
	Message string                  `json:"message"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Services *struct {
		Database   *HealthResponseServicesDatabase   `json:"database,omitempty"`
		Embeddings *HealthResponseServicesEmbeddings `json:"embeddings,omitempty"`
		Scraper    *HealthResponseServicesScraper    `json:"scraper,omitempty"`
	} `json:"services,omitempty"`
	Status    HealthResponseStatus `json:"status"`
	Timestamp time.Time            `json:"timestamp"`
}

// HealthResponseServicesDatabase defines model for HealthResponse.Services.Database.
type HealthResponseServicesDatabase string

// HealthResponseServicesEmbeddings defines model for HealthResponse.Services.Embeddings.
type HealthResponseServicesEmbeddings string

// HealthResponseServicesScraper defines model for HealthResponse.Services.Scraper.
type HealthResponseServicesScraper string

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// ImportResponse defines model for ImportResponse.
type ImportResponse struct {
	Errors *[]struct {
		Error *string `json:"error,omitempty"`
		Url   *string `json:"url,omitempty"`
	} `json:"errors,omitempty"`
	Statistics struct {
		Duplicates           *int `json:"duplicates,omitempty"`
		Failed               *int `json:"failed,omitempty"`
		SuccessfullyImported *int `json:"successfully_imported,omitempty"`
		TotalFound           *int `json:"total_found,omitempty"`
	} `json:"statistics"`
	Status ImportResponseStatus `json:"status"`
}

// ImportResponseStatus defines model for ImportResponse.Status.
type ImportResponseStatus string

// Message defines model for Message.
type Message struct {
	BookmarkRefs *[]openapi_types.UUID `json:"bookmark_refs,omitempty"`
	Content      string                `json:"content"`
	CreatedAt    time.Time             `json:"created_at"`
	Id           openapi_types.UUID    `json:"id"`
	Role         MessageRole           `json:"role"`
}

// MessageRole defines model for Message.Role.
type MessageRole string

// Pagination defines model for Pagination.
type Pagination struct {
	Limit      int `json:"limit"`
	Page       int `json:"page"`
	TotalItems int `json:"total_items"`
	TotalPages int `json:"total_pages"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	Limit      *int                     `json:"limit,omitempty"`
	Query      string                   `json:"query"`
	SearchType *SearchRequestSearchType `json:"search_type,omitempty"`
}

// SearchRequestSearchType defines model for SearchRequest.SearchType.
type SearchRequestSearchType string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Results      []SearchResult `json:"results"`
	TotalResults int            `json:"total_results"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	Bookmark       Bookmark `json:"bookmark"`
	RelevanceScore float32  `json:"relevance_score"`

	// Snippet Highlighted snippet from the content
	Snippet *string `json:"snippet,omitempty"`
}

// StatsResponse defines model for StatsResponse.
type StatsResponse struct {
	BookmarkCount     int `json:"bookmark_count"`
	ConversationCount int `json:"conversation_count"`
	IndexStatus       struct {
		EmbeddingsGenerated *int       `json:"embeddings_generated,omitempty"`
		EmbeddingsPending   *int       `json:"embeddings_pending,omitempty"`
		LastIndexed         *time.Time `json:"last_indexed,omitempty"`
	} `json:"index_status"`
	StorageSizeMb *float32 `json:"storage_size_mb,omitempty"`
}

// BookmarkId defines model for BookmarkId.
type BookmarkId = openapi_types.UUID

// ConversationId defines model for ConversationId.
type ConversationId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// ListBookmarksParams defines parameters for ListBookmarks.
type ListBookmarksParams struct {
	// Page Page number (1-based)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter Filter bookmarks by title or URL
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Sort Sort field and order (e.g., "created_at:desc")
	Sort *ListBookmarksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListBookmarksParamsSort defines parameters for ListBookmarks.
type ListBookmarksParamsSort string

// ImportBookmarksMultipartBody defines parameters for ImportBookmarks.
type ImportBookmarksMultipartBody struct {
	// File Bookmark file (JSON or HTML format)
	File openapi_types.File `json:"file"`
}

// ImportBookmarksMultipartRequestBody defines body for ImportBookmarks for multipart/form-data ContentType.
type ImportBookmarksMultipartRequestBody ImportBookmarksMultipartBody

// UpdateBookmarkJSONRequestBody defines body for UpdateBookmark for application/json ContentType.
type UpdateBookmarkJSONRequestBody = BookmarkUpdate

// SendChatMessageJSONRequestBody defines body for SendChatMessage for application/json ContentType.
type SendChatMessageJSONRequestBody = ChatRequest

// SearchBookmarksJSONRequestBody defines body for SearchBookmarks for application/json ContentType.
type SearchBookmarksJSONRequestBody = SearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all bookmarks
	// (GET /api/bookmarks)
	ListBookmarks(ctx echo.Context, params ListBookmarksParams) error
	// Import bookmarks from file
	// (POST /api/bookmarks/import)
	ImportBookmarks(ctx echo.Context) error
	// Delete bookmark
	// (DELETE /api/bookmarks/{id})
	DeleteBookmark(ctx echo.Context, id BookmarkId) error
	// Get bookmark details
	// (GET /api/bookmarks/{id})
	GetBookmark(ctx echo.Context, id BookmarkId) error
	// Update bookmark
	// (PUT /api/bookmarks/{id})
	UpdateBookmark(ctx echo.Context, id BookmarkId) error
	// Re-scrape bookmark content
	// (POST /api/bookmarks/{id}/rescrape)
	RescrapeBookmark(ctx echo.Context, id BookmarkId) error
	// Send chat message
	// (POST /api/chat)
	SendChatMessage(ctx echo.Context) error
	// List conversations
	// (GET /api/chat/conversations)
	ListConversations(ctx echo.Context) error
	// Get conversation history
	// (GET /api/chat/conversations/{id})
	GetConversation(ctx echo.Context, id ConversationId) error
	// Health check
	// (GET /api/health)
	HealthCheck(ctx echo.Context) error
	// Hybrid search
	// (POST /api/search)
	SearchBookmarks(ctx echo.Context) error
	// System statistics
	// (GET /api/stats)
	GetSystemStats(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) ListBookmarks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBookmarksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBookmarks(ctx, params)
	return err
}

// ImportBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) ImportBookmarks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ImportBookmarks(ctx)
	return err
}

// DeleteBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBookmark(ctx, id)
	return err
}

// GetBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) GetBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBookmark(ctx, id)
	return err
}

// UpdateBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBookmark(ctx, id)
	return err
}

// RescrapeBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) RescrapeBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RescrapeBookmark(ctx, id)
	return err
}

// SendChatMessage converts echo context to params.
func (w *ServerInterfaceWrapper) SendChatMessage(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendChatMessage(ctx)
	return err
}

// ListConversations converts echo context to params.
func (w *ServerInterfaceWrapper) ListConversations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListConversations(ctx)
	return err
}

// GetConversation converts echo context to params.
func (w *ServerInterfaceWrapper) GetConversation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ConversationId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConversation(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// SearchBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchBookmarks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchBookmarks(ctx)
	return err
}

// GetSystemStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStats(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStats(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/bookmarks", wrapper.ListBookmarks)
	router.POST(baseURL+"/api/bookmarks/import", wrapper.ImportBookmarks)
	router.DELETE(baseURL+"/api/bookmarks/:id", wrapper.DeleteBookmark)
	router.GET(baseURL+"/api/bookmarks/:id", wrapper.GetBookmark)
	router.PUT(baseURL+"/api/bookmarks/:id", wrapper.UpdateBookmark)
	router.POST(baseURL+"/api/bookmarks/:id/rescrape", wrapper.RescrapeBookmark)
	router.POST(baseURL+"/api/chat", wrapper.SendChatMessage)
	router.GET(baseURL+"/api/chat/conversations", wrapper.ListConversations)
	router.GET(baseURL+"/api/chat/conversations/:id", wrapper.GetConversation)
	router.GET(baseURL+"/api/health", wrapper.HealthCheck)
	router.POST(baseURL+"/api/search", wrapper.SearchBookmarks)
	router.GET(baseURL+"/api/stats", wrapper.GetSystemStats)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5A6rMwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
