// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for HealthResponseServicesDatabase.
const (
	HealthResponseServicesDatabaseDown HealthResponseServicesDatabase = "down"
	HealthResponseServicesDatabaseUp   HealthResponseServicesDatabase = "up"
)

// Defines values for HealthResponseServicesEmbeddings.
const (
	HealthResponseServicesEmbeddingsDown HealthResponseServicesEmbeddings = "down"
	HealthResponseServicesEmbeddingsUp   HealthResponseServicesEmbeddings = "up"
)

// Defines values for HealthResponseServicesScraper.
const (
	Down HealthResponseServicesScraper = "down"
	Up   HealthResponseServicesScraper = "up"
)

// Defines values for HealthResponseStatus.
const (
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for ImportResponseStatus.
const (
	Failed  ImportResponseStatus = "failed"
	Partial ImportResponseStatus = "partial"
	Success ImportResponseStatus = "success"
)

// Defines values for MessageRole.
const (
	Assistant MessageRole = "assistant"
	User      MessageRole = "user"
)

// Defines values for SearchRequestSearchType.
const (
	Hybrid   SearchRequestSearchType = "hybrid"
	Keyword  SearchRequestSearchType = "keyword"
	Semantic SearchRequestSearchType = "semantic"
)

// Defines values for ListBookmarksParamsSort.
const (
	CreatedAtAsc  ListBookmarksParamsSort = "created_at:asc"
	CreatedAtDesc ListBookmarksParamsSort = "created_at:desc"
	TitleAsc      ListBookmarksParamsSort = "title:asc"
	TitleDesc     ListBookmarksParamsSort = "title:desc"
	UpdatedAtAsc  ListBookmarksParamsSort = "updated_at:asc"
	UpdatedAtDesc ListBookmarksParamsSort = "updated_at:desc"
)

// Bookmark defines model for Bookmark.
type Bookmark struct {
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	FaviconUrl  *string            `json:"favicon_url,omitempty"`
	FolderPath  *string            `json:"folder_path,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	ScrapedAt   *time.Time         `json:"scraped_at,omitempty"`
	Tags        *[]string          `json:"tags,omitempty"`
	Title       *string            `json:"title,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Url         string             `json:"url"`
}

// BookmarkDetail defines model for BookmarkDetail.
type BookmarkDetail struct {
	// Content Scraped content of the bookmark
	Content     *string            `json:"content,omitempty"`
	CreatedAt   time.Time          `json:"created_at"`
	Description *string            `json:"description,omitempty"`
	FaviconUrl  *string            `json:"favicon_url,omitempty"`
	FolderPath  *string            `json:"folder_path,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	ScrapedAt   *time.Time         `json:"scraped_at,omitempty"`
	Tags        *[]string          `json:"tags,omitempty"`
	Title       *string            `json:"title,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Url         string             `json:"url"`
}

// BookmarkListResponse defines model for BookmarkListResponse.
type BookmarkListResponse struct {
	Bookmarks  []Bookmark `json:"bookmarks"`
	Pagination Pagination `json:"pagination"`
}

// BookmarkUpdate defines model for BookmarkUpdate.
type BookmarkUpdate struct {
	Description *string   `json:"description,omitempty"`
	FolderPath  *string   `json:"folder_path,omitempty"`
	Tags        *[]string `json:"tags,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// CategorizationResult defines model for CategorizationResult.
type CategorizationResult struct {
	// ConfidenceScore AI confidence in the categorization
	ConfidenceScore float32 `json:"confidence_score"`

	// PrimaryCategory Most relevant category for the bookmark
	PrimaryCategory string `json:"primary_category"`

	// Reasoning Brief explanation of the categorization decision
	Reasoning *string `json:"reasoning,omitempty"`

	// SecondaryCategories Additional relevant categories
	SecondaryCategories *[]string `json:"secondary_categories,omitempty"`

	// Tags Specific tags for enhanced searchability
	Tags *[]string `json:"tags,omitempty"`
}

// Category defines model for Category.
type Category struct {
	// Color Color code for UI display
	Color *string `json:"color,omitempty"`

	// CreatedAt Category creation timestamp
	CreatedAt time.Time `json:"created_at"`

	// Id Unique category identifier
	Id int `json:"id"`

	// Name Category name
	Name string `json:"name"`

	// ParentCategory Parent category for hierarchical organization
	ParentCategory *string `json:"parent_category"`

	// UpdatedAt Last update timestamp
	UpdatedAt time.Time `json:"updated_at"`

	// UsageCount Number of bookmarks using this category
	UsageCount int `json:"usage_count"`
}

// ChatRequest defines model for ChatRequest.
type ChatRequest struct {
	// Context Additional context bookmark IDs
	Context        *[]string           `json:"context,omitempty"`
	ConversationId *openapi_types.UUID `json:"conversation_id,omitempty"`
	Message        string              `json:"message"`
}

// ChatResponse defines model for ChatResponse.
type ChatResponse struct {
	ConversationId openapi_types.UUID `json:"conversation_id"`
	Reply          string             `json:"reply"`
	Sources        *[]Bookmark        `json:"sources,omitempty"`
}

// ConversationDetail defines model for ConversationDetail.
type ConversationDetail struct {
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Messages  []Message          `json:"messages"`
	Title     string             `json:"title"`
	UpdatedAt time.Time          `json:"updated_at"`
}

// ConversationListResponse defines model for ConversationListResponse.
type ConversationListResponse struct {
	Conversations []ConversationSummary `json:"conversations"`
}

// ConversationSummary defines model for ConversationSummary.
type ConversationSummary struct {
	CreatedAt    time.Time          `json:"created_at"`
	Id           openapi_types.UUID `json:"id"`
	MessageCount *int               `json:"message_count,omitempty"`
	Title        string             `json:"title"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

// Error defines model for Error.
type Error struct {
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   string                  `json:"error"`
	Message string                  `json:"message"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Services *struct {
		Database   *HealthResponseServicesDatabase   `json:"database,omitempty"`
		Embeddings *HealthResponseServicesEmbeddings `json:"embeddings,omitempty"`
		Scraper    *HealthResponseServicesScraper    `json:"scraper,omitempty"`
	} `json:"services,omitempty"`
	Status    HealthResponseStatus `json:"status"`
	Timestamp time.Time            `json:"timestamp"`
}

// HealthResponseServicesDatabase defines model for HealthResponse.Services.Database.
type HealthResponseServicesDatabase string

// HealthResponseServicesEmbeddings defines model for HealthResponse.Services.Embeddings.
type HealthResponseServicesEmbeddings string

// HealthResponseServicesScraper defines model for HealthResponse.Services.Scraper.
type HealthResponseServicesScraper string

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// ImportResponse defines model for ImportResponse.
type ImportResponse struct {
	Errors *[]struct {
		Error *string `json:"error,omitempty"`
		Url   *string `json:"url,omitempty"`
	} `json:"errors,omitempty"`
	Statistics struct {
		Duplicates           *int `json:"duplicates,omitempty"`
		Failed               *int `json:"failed,omitempty"`
		SuccessfullyImported *int `json:"successfully_imported,omitempty"`
		TotalFound           *int `json:"total_found,omitempty"`
	} `json:"statistics"`
	Status ImportResponseStatus `json:"status"`
}

// ImportResponseStatus defines model for ImportResponse.Status.
type ImportResponseStatus string

// Message defines model for Message.
type Message struct {
	BookmarkRefs *[]openapi_types.UUID `json:"bookmark_refs,omitempty"`
	Content      string                `json:"content"`
	CreatedAt    time.Time             `json:"created_at"`
	Id           openapi_types.UUID    `json:"id"`
	Role         MessageRole           `json:"role"`
}

// MessageRole defines model for Message.Role.
type MessageRole string

// Pagination defines model for Pagination.
type Pagination struct {
	Limit      int `json:"limit"`
	Page       int `json:"page"`
	TotalItems int `json:"total_items"`
	TotalPages int `json:"total_pages"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	Limit      *int                     `json:"limit,omitempty"`
	Query      string                   `json:"query"`
	SearchType *SearchRequestSearchType `json:"search_type,omitempty"`
}

// SearchRequestSearchType defines model for SearchRequest.SearchType.
type SearchRequestSearchType string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Results      []SearchResult `json:"results"`
	TotalResults int            `json:"total_results"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	Bookmark       Bookmark `json:"bookmark"`
	RelevanceScore float32  `json:"relevance_score"`

	// Snippet Highlighted snippet from the content
	Snippet *string `json:"snippet,omitempty"`
}

// StatsResponse defines model for StatsResponse.
type StatsResponse struct {
	BookmarkCount     int `json:"bookmark_count"`
	ConversationCount int `json:"conversation_count"`
	IndexStatus       struct {
		EmbeddingsGenerated *int       `json:"embeddings_generated,omitempty"`
		EmbeddingsPending   *int       `json:"embeddings_pending,omitempty"`
		LastIndexed         *time.Time `json:"last_indexed,omitempty"`
	} `json:"index_status"`
	StorageSizeMb *float32 `json:"storage_size_mb,omitempty"`
}

// BookmarkId defines model for BookmarkId.
type BookmarkId = openapi_types.UUID

// ConversationId defines model for ConversationId.
type ConversationId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// ListBookmarksParams defines parameters for ListBookmarks.
type ListBookmarksParams struct {
	// Page Page number (1-based)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Number of items per page
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter Filter bookmarks by title or URL
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Sort Sort field and order (e.g., "created_at:desc")
	Sort *ListBookmarksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListBookmarksParamsSort defines parameters for ListBookmarks.
type ListBookmarksParamsSort string

// CategorizeBulkJSONBody defines parameters for CategorizeBulk.
type CategorizeBulkJSONBody struct {
	// AutoApply Automatically apply categorizations above threshold
	AutoApply *bool `json:"auto_apply,omitempty"`

	// BookmarkIds Array of bookmark IDs to categorize
	BookmarkIds []openapi_types.UUID `json:"bookmark_ids"`

	// ConfidenceThreshold Confidence threshold for auto-apply
	ConfidenceThreshold *float32 `json:"confidence_threshold,omitempty"`
}

// ImportBookmarksMultipartBody defines parameters for ImportBookmarks.
type ImportBookmarksMultipartBody struct {
	// File Bookmark file (JSON or HTML format)
	File openapi_types.File `json:"file"`
}

// StartScrapingJSONBody defines parameters for StartScraping.
type StartScrapingJSONBody struct {
	// BookmarkIds Array of bookmark IDs to scrape
	BookmarkIds []openapi_types.UUID `json:"bookmark_ids"`
}

// CategorizeBulkJSONRequestBody defines body for CategorizeBulk for application/json ContentType.
type CategorizeBulkJSONRequestBody CategorizeBulkJSONBody

// ImportBookmarksMultipartRequestBody defines body for ImportBookmarks for multipart/form-data ContentType.
type ImportBookmarksMultipartRequestBody ImportBookmarksMultipartBody

// UpdateBookmarkJSONRequestBody defines body for UpdateBookmark for application/json ContentType.
type UpdateBookmarkJSONRequestBody = BookmarkUpdate

// SendChatMessageJSONRequestBody defines body for SendChatMessage for application/json ContentType.
type SendChatMessageJSONRequestBody = ChatRequest

// StartScrapingJSONRequestBody defines body for StartScraping for application/json ContentType.
type StartScrapingJSONRequestBody StartScrapingJSONBody

// SearchBookmarksJSONRequestBody defines body for SearchBookmarks for application/json ContentType.
type SearchBookmarksJSONRequestBody = SearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all bookmarks
	// (GET /api/bookmarks)
	ListBookmarks(ctx echo.Context, params ListBookmarksParams) error
	// Bulk categorize bookmarks
	// (POST /api/bookmarks/categorize/bulk)
	CategorizeBulk(ctx echo.Context) error
	// Import bookmarks from file
	// (POST /api/bookmarks/import)
	ImportBookmarks(ctx echo.Context) error
	// Delete bookmark
	// (DELETE /api/bookmarks/{id})
	DeleteBookmark(ctx echo.Context, id BookmarkId) error
	// Get bookmark details
	// (GET /api/bookmarks/{id})
	GetBookmark(ctx echo.Context, id BookmarkId) error
	// Update bookmark
	// (PUT /api/bookmarks/{id})
	UpdateBookmark(ctx echo.Context, id BookmarkId) error
	// Categorize a single bookmark using AI
	// (POST /api/bookmarks/{id}/categorize)
	CategorizeBookmark(ctx echo.Context, id BookmarkId) error
	// Re-scrape bookmark content
	// (POST /api/bookmarks/{id}/rescrape)
	RescrapeBookmark(ctx echo.Context, id BookmarkId) error
	// Get all user categories
	// (GET /api/categories)
	GetCategories(ctx echo.Context) error
	// Send chat message
	// (POST /api/chat)
	SendChatMessage(ctx echo.Context) error
	// List conversations
	// (GET /api/chat/conversations)
	ListConversations(ctx echo.Context) error
	// Get conversation history
	// (GET /api/chat/conversations/{id})
	GetConversation(ctx echo.Context, id ConversationId) error
	// Health check
	// (GET /api/health)
	HealthCheck(ctx echo.Context) error
	// Pause scraping process
	// (POST /api/scraping/pause)
	PauseScraping(ctx echo.Context) error
	// Resume scraping process
	// (POST /api/scraping/resume)
	ResumeScraping(ctx echo.Context) error
	// Start bulk scraping process
	// (POST /api/scraping/start)
	StartScraping(ctx echo.Context) error
	// Get scraping status
	// (GET /api/scraping/status)
	GetScrapingStatus(ctx echo.Context) error
	// Stop scraping process
	// (POST /api/scraping/stop)
	StopScraping(ctx echo.Context) error
	// Hybrid search
	// (POST /api/search)
	SearchBookmarks(ctx echo.Context) error
	// System statistics
	// (GET /api/stats)
	GetSystemStats(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) ListBookmarks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBookmarksParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBookmarks(ctx, params)
	return err
}

// CategorizeBulk converts echo context to params.
func (w *ServerInterfaceWrapper) CategorizeBulk(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CategorizeBulk(ctx)
	return err
}

// ImportBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) ImportBookmarks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ImportBookmarks(ctx)
	return err
}

// DeleteBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBookmark(ctx, id)
	return err
}

// GetBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) GetBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBookmark(ctx, id)
	return err
}

// UpdateBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBookmark(ctx, id)
	return err
}

// CategorizeBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) CategorizeBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CategorizeBookmark(ctx, id)
	return err
}

// RescrapeBookmark converts echo context to params.
func (w *ServerInterfaceWrapper) RescrapeBookmark(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id BookmarkId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RescrapeBookmark(ctx, id)
	return err
}

// GetCategories converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategories(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategories(ctx)
	return err
}

// SendChatMessage converts echo context to params.
func (w *ServerInterfaceWrapper) SendChatMessage(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SendChatMessage(ctx)
	return err
}

// ListConversations converts echo context to params.
func (w *ServerInterfaceWrapper) ListConversations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListConversations(ctx)
	return err
}

// GetConversation converts echo context to params.
func (w *ServerInterfaceWrapper) GetConversation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id ConversationId

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConversation(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// PauseScraping converts echo context to params.
func (w *ServerInterfaceWrapper) PauseScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PauseScraping(ctx)
	return err
}

// ResumeScraping converts echo context to params.
func (w *ServerInterfaceWrapper) ResumeScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ResumeScraping(ctx)
	return err
}

// StartScraping converts echo context to params.
func (w *ServerInterfaceWrapper) StartScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartScraping(ctx)
	return err
}

// GetScrapingStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetScrapingStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScrapingStatus(ctx)
	return err
}

// StopScraping converts echo context to params.
func (w *ServerInterfaceWrapper) StopScraping(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StopScraping(ctx)
	return err
}

// SearchBookmarks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchBookmarks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchBookmarks(ctx)
	return err
}

// GetSystemStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetSystemStats(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSystemStats(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/bookmarks", wrapper.ListBookmarks)
	router.POST(baseURL+"/api/bookmarks/categorize/bulk", wrapper.CategorizeBulk)
	router.POST(baseURL+"/api/bookmarks/import", wrapper.ImportBookmarks)
	router.DELETE(baseURL+"/api/bookmarks/:id", wrapper.DeleteBookmark)
	router.GET(baseURL+"/api/bookmarks/:id", wrapper.GetBookmark)
	router.PUT(baseURL+"/api/bookmarks/:id", wrapper.UpdateBookmark)
	router.POST(baseURL+"/api/bookmarks/:id/categorize", wrapper.CategorizeBookmark)
	router.POST(baseURL+"/api/bookmarks/:id/rescrape", wrapper.RescrapeBookmark)
	router.GET(baseURL+"/api/categories", wrapper.GetCategories)
	router.POST(baseURL+"/api/chat", wrapper.SendChatMessage)
	router.GET(baseURL+"/api/chat/conversations", wrapper.ListConversations)
	router.GET(baseURL+"/api/chat/conversations/:id", wrapper.GetConversation)
	router.GET(baseURL+"/api/health", wrapper.HealthCheck)
	router.POST(baseURL+"/api/scraping/pause", wrapper.PauseScraping)
	router.POST(baseURL+"/api/scraping/resume", wrapper.ResumeScraping)
	router.POST(baseURL+"/api/scraping/start", wrapper.StartScraping)
	router.GET(baseURL+"/api/scraping/status", wrapper.GetScrapingStatus)
	router.POST(baseURL+"/api/scraping/stop", wrapper.StopScraping)
	router.POST(baseURL+"/api/search", wrapper.SearchBookmarks)
	router.GET(baseURL+"/api/stats", wrapper.GetSystemStats)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
